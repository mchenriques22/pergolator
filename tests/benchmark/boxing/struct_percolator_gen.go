// Code generated by github.com/antoninferrand/pergolator, DO NOT EDIT.
package boxing

import (
	"reflect"
	"strconv"
	"strings"

	"github.com/antoninferrand/pergolator/tree"
)

type RootPercolator struct {
	fn func(document *Root) bool
}

// Percolate percolates the document with the percolator's query.
// It will return a boolean indicating if the query matches the document.
func (p *RootPercolator) Percolate(document *Root) bool {
	return p.fn(document)
}

// NewRootPercolatorConstructor is a constructor of percolators.
// Every percolator it creates will use the parser provided to the constructor.
func NewRootPercolatorConstructor(parseFn tree.ParseFn, modifiers ...tree.Modifiers) func(query string) (*RootPercolator, error) {
	return func(query string) (*RootPercolator, error) {
		return NewRootPercolator(parseFn, query, modifiers...)
	}
}

// NewRootPercolator creates a percolator with a given query and a given parser.
// It returns an error if the parsing failed.
func NewRootPercolator(parseFn tree.ParseFn, query string, modifiers ...tree.Modifiers) (*RootPercolator, error) {
	root, err := parseFn(query)
	if err != nil {
		return nil, err
	}

	for _, modifier := range modifiers {
		root = modifier(root)
		if _, isEmpty := root.(*tree.Empty); isEmpty {
			// If the query is empty, we return a percolator that always returns false
			return &RootPercolator{fn: pRootFalseFn}, nil
		}
	}

	return &RootPercolator{fn: updateNodeRoot(root)}, nil
}

func updateNodeRoot(root tree.Expr) func(document *Root) bool {
	switch r := root.(type) {
	case *tree.And:
		fns := make([]func(document *Root) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeRoot(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pRootFalseFn).Pointer() {
				return pRootFalseFn
			}
			fns = append(fns, fn)
		}

		return func(document *Root) bool {
			for _, fn := range fns {
				if !fn(document) {
					return false
				}
			}
			return true
		}
	case *tree.Or:
		fns := make([]func(document *Root) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeRoot(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pRootFalseFn).Pointer() {
				continue
			}
			fns = append(fns, fn)
		}

		if len(fns) == 0 {
			return pRootFalseFn
		}

		return func(document *Root) bool {
			for _, fn := range fns {
				if fn(document) {
					return true
				}
			}
			return false
		}
	case *tree.Not:
		child := updateNodeRoot(r.Child)
		return func(document *Root) bool {
			return !child(document)
		}
	case *tree.Query:
		return pRootQuery(r)
	}

	return pRootFalseFn
}

type APercolator struct {
	fn func(document *A) bool
}

// Percolate percolates the document with the percolator's query.
// It will return a boolean indicating if the query matches the document.
func (p *APercolator) Percolate(document *A) bool {
	return p.fn(document)
}

// NewAPercolatorConstructor is a constructor of percolators.
// Every percolator it creates will use the parser provided to the constructor.
func NewAPercolatorConstructor(parseFn tree.ParseFn, modifiers ...tree.Modifiers) func(query string) (*APercolator, error) {
	return func(query string) (*APercolator, error) {
		return NewAPercolator(parseFn, query, modifiers...)
	}
}

// NewAPercolator creates a percolator with a given query and a given parser.
// It returns an error if the parsing failed.
func NewAPercolator(parseFn tree.ParseFn, query string, modifiers ...tree.Modifiers) (*APercolator, error) {
	root, err := parseFn(query)
	if err != nil {
		return nil, err
	}

	for _, modifier := range modifiers {
		root = modifier(root)
		if _, isEmpty := root.(*tree.Empty); isEmpty {
			// If the query is empty, we return a percolator that always returns false
			return &APercolator{fn: pAFalseFn}, nil
		}
	}

	return &APercolator{fn: updateNodeA(root)}, nil
}

func updateNodeA(root tree.Expr) func(document *A) bool {
	switch r := root.(type) {
	case *tree.And:
		fns := make([]func(document *A) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeA(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pAFalseFn).Pointer() {
				return pAFalseFn
			}
			fns = append(fns, fn)
		}

		return func(document *A) bool {
			for _, fn := range fns {
				if !fn(document) {
					return false
				}
			}
			return true
		}
	case *tree.Or:
		fns := make([]func(document *A) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeA(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pAFalseFn).Pointer() {
				continue
			}
			fns = append(fns, fn)
		}

		if len(fns) == 0 {
			return pAFalseFn
		}

		return func(document *A) bool {
			for _, fn := range fns {
				if fn(document) {
					return true
				}
			}
			return false
		}
	case *tree.Not:
		child := updateNodeA(r.Child)
		return func(document *A) bool {
			return !child(document)
		}
	case *tree.Query:
		return pAQuery(r)
	}

	return pAFalseFn
}

type BPercolator struct {
	fn func(document *B) bool
}

// Percolate percolates the document with the percolator's query.
// It will return a boolean indicating if the query matches the document.
func (p *BPercolator) Percolate(document *B) bool {
	return p.fn(document)
}

// NewBPercolatorConstructor is a constructor of percolators.
// Every percolator it creates will use the parser provided to the constructor.
func NewBPercolatorConstructor(parseFn tree.ParseFn, modifiers ...tree.Modifiers) func(query string) (*BPercolator, error) {
	return func(query string) (*BPercolator, error) {
		return NewBPercolator(parseFn, query, modifiers...)
	}
}

// NewBPercolator creates a percolator with a given query and a given parser.
// It returns an error if the parsing failed.
func NewBPercolator(parseFn tree.ParseFn, query string, modifiers ...tree.Modifiers) (*BPercolator, error) {
	root, err := parseFn(query)
	if err != nil {
		return nil, err
	}

	for _, modifier := range modifiers {
		root = modifier(root)
		if _, isEmpty := root.(*tree.Empty); isEmpty {
			// If the query is empty, we return a percolator that always returns false
			return &BPercolator{fn: pBFalseFn}, nil
		}
	}

	return &BPercolator{fn: updateNodeB(root)}, nil
}

func updateNodeB(root tree.Expr) func(document *B) bool {
	switch r := root.(type) {
	case *tree.And:
		fns := make([]func(document *B) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeB(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pBFalseFn).Pointer() {
				return pBFalseFn
			}
			fns = append(fns, fn)
		}

		return func(document *B) bool {
			for _, fn := range fns {
				if !fn(document) {
					return false
				}
			}
			return true
		}
	case *tree.Or:
		fns := make([]func(document *B) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeB(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pBFalseFn).Pointer() {
				continue
			}
			fns = append(fns, fn)
		}

		if len(fns) == 0 {
			return pBFalseFn
		}

		return func(document *B) bool {
			for _, fn := range fns {
				if fn(document) {
					return true
				}
			}
			return false
		}
	case *tree.Not:
		child := updateNodeB(r.Child)
		return func(document *B) bool {
			return !child(document)
		}
	case *tree.Query:
		return pBQuery(r)
	}

	return pBFalseFn
}

type CPercolator struct {
	fn func(document *C) bool
}

// Percolate percolates the document with the percolator's query.
// It will return a boolean indicating if the query matches the document.
func (p *CPercolator) Percolate(document *C) bool {
	return p.fn(document)
}

// NewCPercolatorConstructor is a constructor of percolators.
// Every percolator it creates will use the parser provided to the constructor.
func NewCPercolatorConstructor(parseFn tree.ParseFn, modifiers ...tree.Modifiers) func(query string) (*CPercolator, error) {
	return func(query string) (*CPercolator, error) {
		return NewCPercolator(parseFn, query, modifiers...)
	}
}

// NewCPercolator creates a percolator with a given query and a given parser.
// It returns an error if the parsing failed.
func NewCPercolator(parseFn tree.ParseFn, query string, modifiers ...tree.Modifiers) (*CPercolator, error) {
	root, err := parseFn(query)
	if err != nil {
		return nil, err
	}

	for _, modifier := range modifiers {
		root = modifier(root)
		if _, isEmpty := root.(*tree.Empty); isEmpty {
			// If the query is empty, we return a percolator that always returns false
			return &CPercolator{fn: pCFalseFn}, nil
		}
	}

	return &CPercolator{fn: updateNodeC(root)}, nil
}

func updateNodeC(root tree.Expr) func(document *C) bool {
	switch r := root.(type) {
	case *tree.And:
		fns := make([]func(document *C) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeC(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pCFalseFn).Pointer() {
				return pCFalseFn
			}
			fns = append(fns, fn)
		}

		return func(document *C) bool {
			for _, fn := range fns {
				if !fn(document) {
					return false
				}
			}
			return true
		}
	case *tree.Or:
		fns := make([]func(document *C) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeC(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pCFalseFn).Pointer() {
				continue
			}
			fns = append(fns, fn)
		}

		if len(fns) == 0 {
			return pCFalseFn
		}

		return func(document *C) bool {
			for _, fn := range fns {
				if fn(document) {
					return true
				}
			}
			return false
		}
	case *tree.Not:
		child := updateNodeC(r.Child)
		return func(document *C) bool {
			return !child(document)
		}
	case *tree.Query:
		return pCQuery(r)
	}

	return pCFalseFn
}

type DPercolator struct {
	fn func(document *D) bool
}

// Percolate percolates the document with the percolator's query.
// It will return a boolean indicating if the query matches the document.
func (p *DPercolator) Percolate(document *D) bool {
	return p.fn(document)
}

// NewDPercolatorConstructor is a constructor of percolators.
// Every percolator it creates will use the parser provided to the constructor.
func NewDPercolatorConstructor(parseFn tree.ParseFn, modifiers ...tree.Modifiers) func(query string) (*DPercolator, error) {
	return func(query string) (*DPercolator, error) {
		return NewDPercolator(parseFn, query, modifiers...)
	}
}

// NewDPercolator creates a percolator with a given query and a given parser.
// It returns an error if the parsing failed.
func NewDPercolator(parseFn tree.ParseFn, query string, modifiers ...tree.Modifiers) (*DPercolator, error) {
	root, err := parseFn(query)
	if err != nil {
		return nil, err
	}

	for _, modifier := range modifiers {
		root = modifier(root)
		if _, isEmpty := root.(*tree.Empty); isEmpty {
			// If the query is empty, we return a percolator that always returns false
			return &DPercolator{fn: pDFalseFn}, nil
		}
	}

	return &DPercolator{fn: updateNodeD(root)}, nil
}

func updateNodeD(root tree.Expr) func(document *D) bool {
	switch r := root.(type) {
	case *tree.And:
		fns := make([]func(document *D) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeD(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pDFalseFn).Pointer() {
				return pDFalseFn
			}
			fns = append(fns, fn)
		}

		return func(document *D) bool {
			for _, fn := range fns {
				if !fn(document) {
					return false
				}
			}
			return true
		}
	case *tree.Or:
		fns := make([]func(document *D) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeD(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pDFalseFn).Pointer() {
				continue
			}
			fns = append(fns, fn)
		}

		if len(fns) == 0 {
			return pDFalseFn
		}

		return func(document *D) bool {
			for _, fn := range fns {
				if fn(document) {
					return true
				}
			}
			return false
		}
	case *tree.Not:
		child := updateNodeD(r.Child)
		return func(document *D) bool {
			return !child(document)
		}
	case *tree.Query:
		return pDQuery(r)
	}

	return pDFalseFn
}

func pRootQuery(query *tree.Query) func(*Root) bool {
	key, suffix, _ := strings.Cut(query.Key, ".")
	_ = suffix
	switch key {
	case "A":
		fn := pAQuery(&tree.Query{
			Key:   suffix,
			Sign:  query.Sign,
			Value: query.Value,
		})
		return func(document *Root) bool {
			return fn(&document.A)
		}
	case "Value":
		parsed, err := strconv.ParseInt(query.Value, 10, 64)
		if err != nil {
			return pRootFalseFn
		}
		switch query.Sign {
		case tree.Eq:
			return func(document *Root) bool {
				return document.Value == parsed
			}
		case tree.Gte:
			return func(document *Root) bool {
				return document.Value >= parsed
			}
		case tree.Gt:
			return func(document *Root) bool {
				return document.Value > parsed
			}
		case tree.Lte:
			return func(document *Root) bool {
				return document.Value <= parsed
			}
		case tree.Lt:
			return func(document *Root) bool {
				return document.Value < parsed
			}
		default:
			return pRootFalseFn
		}
	default:
		return pRootFalseFn
	}
}

func pRootFalseFn(_ *Root) bool {
	return false
}

func pAQuery(query *tree.Query) func(*A) bool {
	key, suffix, _ := strings.Cut(query.Key, ".")
	_ = suffix
	switch key {
	case "B":
		fn := pBQuery(&tree.Query{
			Key:   suffix,
			Sign:  query.Sign,
			Value: query.Value,
		})
		return func(document *A) bool {
			return fn(&document.B)
		}
	case "Value":
		parsed, err := strconv.ParseInt(query.Value, 10, 64)
		if err != nil {
			return pAFalseFn
		}
		switch query.Sign {
		case tree.Eq:
			return func(document *A) bool {
				return document.Value == parsed
			}
		case tree.Gte:
			return func(document *A) bool {
				return document.Value >= parsed
			}
		case tree.Gt:
			return func(document *A) bool {
				return document.Value > parsed
			}
		case tree.Lte:
			return func(document *A) bool {
				return document.Value <= parsed
			}
		case tree.Lt:
			return func(document *A) bool {
				return document.Value < parsed
			}
		default:
			return pAFalseFn
		}
	default:
		return pAFalseFn
	}
}

func pAFalseFn(_ *A) bool {
	return false
}

func pBQuery(query *tree.Query) func(*B) bool {
	key, suffix, _ := strings.Cut(query.Key, ".")
	_ = suffix
	switch key {
	case "C":
		fn := pCQuery(&tree.Query{
			Key:   suffix,
			Sign:  query.Sign,
			Value: query.Value,
		})
		return func(document *B) bool {
			return fn(&document.C)
		}
	case "Value":
		parsed, err := strconv.ParseInt(query.Value, 10, 64)
		if err != nil {
			return pBFalseFn
		}
		switch query.Sign {
		case tree.Eq:
			return func(document *B) bool {
				return document.Value == parsed
			}
		case tree.Gte:
			return func(document *B) bool {
				return document.Value >= parsed
			}
		case tree.Gt:
			return func(document *B) bool {
				return document.Value > parsed
			}
		case tree.Lte:
			return func(document *B) bool {
				return document.Value <= parsed
			}
		case tree.Lt:
			return func(document *B) bool {
				return document.Value < parsed
			}
		default:
			return pBFalseFn
		}
	default:
		return pBFalseFn
	}
}

func pBFalseFn(_ *B) bool {
	return false
}

func pCQuery(query *tree.Query) func(*C) bool {
	key, suffix, _ := strings.Cut(query.Key, ".")
	_ = suffix
	switch key {
	case "D":
		fn := pDQuery(&tree.Query{
			Key:   suffix,
			Sign:  query.Sign,
			Value: query.Value,
		})
		return func(document *C) bool {
			return fn(&document.D)
		}
	case "Value":
		parsed, err := strconv.ParseInt(query.Value, 10, 64)
		if err != nil {
			return pCFalseFn
		}
		switch query.Sign {
		case tree.Eq:
			return func(document *C) bool {
				return document.Value == parsed
			}
		case tree.Gte:
			return func(document *C) bool {
				return document.Value >= parsed
			}
		case tree.Gt:
			return func(document *C) bool {
				return document.Value > parsed
			}
		case tree.Lte:
			return func(document *C) bool {
				return document.Value <= parsed
			}
		case tree.Lt:
			return func(document *C) bool {
				return document.Value < parsed
			}
		default:
			return pCFalseFn
		}
	default:
		return pCFalseFn
	}
}

func pCFalseFn(_ *C) bool {
	return false
}

func pDQuery(query *tree.Query) func(*D) bool {
	key, suffix, _ := strings.Cut(query.Key, ".")
	_ = suffix
	switch key {
	case "Value":
		parsed, err := strconv.ParseInt(query.Value, 10, 64)
		if err != nil {
			return pDFalseFn
		}
		switch query.Sign {
		case tree.Eq:
			return func(document *D) bool {
				return document.Value == parsed
			}
		case tree.Gte:
			return func(document *D) bool {
				return document.Value >= parsed
			}
		case tree.Gt:
			return func(document *D) bool {
				return document.Value > parsed
			}
		case tree.Lte:
			return func(document *D) bool {
				return document.Value <= parsed
			}
		case tree.Lt:
			return func(document *D) bool {
				return document.Value < parsed
			}
		default:
			return pDFalseFn
		}
	default:
		return pDFalseFn
	}
}

func pDFalseFn(_ *D) bool {
	return false
}
