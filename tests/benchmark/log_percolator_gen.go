// Code generated by github.com/mchenriques22/pergolator, DO NOT EDIT.
package benchmark

import (
	"reflect"
	"strconv"
	"strings"

	"github.com/mchenriques22/pergolator/tree"
)

type LogPercolator struct {
	fn func(document *Log) bool
}

// Percolate percolates the document with the percolator's query.
// It will return a boolean indicating if the query matches the document.
func (p *LogPercolator) Percolate(document *Log) bool {
	return p.fn(document)
}

// NewLogPercolatorConstructor is a constructor of percolators.
// Every percolator it creates will use the parser provided to the constructor.
func NewLogPercolatorConstructor(parseFn tree.ParseFn, modifiers ...tree.Modifiers) func(query string) (*LogPercolator, error) {
	return func(query string) (*LogPercolator, error) {
		return NewLogPercolator(parseFn, query, modifiers...)
	}
}

// NewLogPercolator creates a percolator with a given query and a given parser.
// It returns an error if the parsing failed.
func NewLogPercolator(parseFn tree.ParseFn, query string, modifiers ...tree.Modifiers) (*LogPercolator, error) {
	root, err := parseFn(query)
	if err != nil {
		return nil, err
	}

	for _, modifier := range modifiers {
		root = modifier(root)
		if _, isEmpty := root.(*tree.Empty); isEmpty {
			// If the query is empty, we return a percolator that always returns false
			return &LogPercolator{fn: pLogFalseFn}, nil
		}
	}

	return &LogPercolator{fn: updateNodeLog(root)}, nil
}

func updateNodeLog(root tree.Expr) func(document *Log) bool {
	switch r := root.(type) {
	case *tree.And:
		fns := make([]func(document *Log) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeLog(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pLogFalseFn).Pointer() {
				return pLogFalseFn
			}
			fns = append(fns, fn)
		}

		return func(document *Log) bool {
			for _, fn := range fns {
				if !fn(document) {
					return false
				}
			}
			return true
		}
	case *tree.Or:
		fns := make([]func(document *Log) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeLog(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pLogFalseFn).Pointer() {
				continue
			}
			fns = append(fns, fn)
		}

		if len(fns) == 0 {
			return pLogFalseFn
		}

		return func(document *Log) bool {
			for _, fn := range fns {
				if fn(document) {
					return true
				}
			}
			return false
		}
	case *tree.Not:
		child := updateNodeLog(r.Child)
		return func(document *Log) bool {
			return !child(document)
		}
	case *tree.Query:
		return pLogQuery(r)
	}

	return pLogFalseFn
}

func pLogQuery(query *tree.Query) func(*Log) bool {
	key, suffix, _ := strings.Cut(query.Key, ".")
	_ = suffix
	switch key {
	case "TraceID":
		parsed, err := strconv.ParseUint(query.Value, 10, 64)
		if err != nil {
			return pLogFalseFn
		}
		switch query.Sign {
		case tree.Eq:
			return func(document *Log) bool {
				return document.TraceID == parsed
			}
		case tree.Gte:
			return func(document *Log) bool {
				return document.TraceID >= parsed
			}
		case tree.Gt:
			return func(document *Log) bool {
				return document.TraceID > parsed
			}
		case tree.Lte:
			return func(document *Log) bool {
				return document.TraceID <= parsed
			}
		case tree.Lt:
			return func(document *Log) bool {
				return document.TraceID < parsed
			}
		default:
			return pLogFalseFn
		}
	case "SpanID":
		parsed, err := strconv.ParseUint(query.Value, 10, 64)
		if err != nil {
			return pLogFalseFn
		}
		switch query.Sign {
		case tree.Eq:
			return func(document *Log) bool {
				return document.SpanID == parsed
			}
		case tree.Gte:
			return func(document *Log) bool {
				return document.SpanID >= parsed
			}
		case tree.Gt:
			return func(document *Log) bool {
				return document.SpanID > parsed
			}
		case tree.Lte:
			return func(document *Log) bool {
				return document.SpanID <= parsed
			}
		case tree.Lt:
			return func(document *Log) bool {
				return document.SpanID < parsed
			}
		default:
			return pLogFalseFn
		}
	case "Timestamp":
		parsed, err := strconv.ParseInt(query.Value, 10, 64)
		if err != nil {
			return pLogFalseFn
		}
		switch query.Sign {
		case tree.Eq:
			return func(document *Log) bool {
				return document.Timestamp == parsed
			}
		case tree.Gte:
			return func(document *Log) bool {
				return document.Timestamp >= parsed
			}
		case tree.Gt:
			return func(document *Log) bool {
				return document.Timestamp > parsed
			}
		case tree.Lte:
			return func(document *Log) bool {
				return document.Timestamp <= parsed
			}
		case tree.Lt:
			return func(document *Log) bool {
				return document.Timestamp < parsed
			}
		default:
			return pLogFalseFn
		}
	case "Service":
		parsed := query.Value
		return func(document *Log) bool {
			return document.Service == parsed
		}
	case "Level":
		parsed := query.Value
		return func(document *Log) bool {
			return document.Level == parsed
		}
	case "Message":
		parsed := query.Value
		return func(document *Log) bool {
			return document.Message == parsed
		}
	case "Error":
		parsed := query.Value
		return func(document *Log) bool {
			return document.Error == parsed
		}
	case "Tags":
		parsed := query.Value
		return func(document *Log) bool {
			value, found := document.Tags[suffix]
			return found && value == parsed
		}
	default:
		return pLogFalseFn
	}
}

func pLogFalseFn(_ *Log) bool {
	return false
}
