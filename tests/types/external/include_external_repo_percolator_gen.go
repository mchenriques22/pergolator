// Code generated by github.com/mchenriques22/pergolator, DO NOT EDIT.
package external

import (
	"reflect"
	"time"

	"github.com/dave/jennifer/jen"

	"github.com/mchenriques22/pergolator/tree"
)

type IncludeExternalRepoPercolator struct {
	fn func(document *IncludeExternalRepo) bool
}

// Percolate percolates the document with the percolator's query.
// It will return a boolean indicating if the query matches the document.
func (p *IncludeExternalRepoPercolator) Percolate(document *IncludeExternalRepo) bool {
	return p.fn(document)
}

// NewIncludeExternalRepoPercolatorConstructor is a constructor of percolators.
// Every percolator it creates will use the parser provided to the constructor.
func NewIncludeExternalRepoPercolatorConstructor(parseFn tree.ParseFn, modifiers ...tree.Modifiers) func(query string) (*IncludeExternalRepoPercolator, error) {
	return func(query string) (*IncludeExternalRepoPercolator, error) {
		return NewIncludeExternalRepoPercolator(parseFn, query, modifiers...)
	}
}

// NewIncludeExternalRepoPercolator creates a percolator with a given query and a given parser.
// It returns an error if the parsing failed.
func NewIncludeExternalRepoPercolator(parseFn tree.ParseFn, query string, modifiers ...tree.Modifiers) (*IncludeExternalRepoPercolator, error) {
	root, err := parseFn(query)
	if err != nil {
		return nil, err
	}

	for _, modifier := range modifiers {
		root = modifier(root)
		if _, isEmpty := root.(*tree.Empty); isEmpty {
			// If the query is empty, we return a percolator that always returns false
			return &IncludeExternalRepoPercolator{fn: pIncludeExternalRepoFalseFn}, nil
		}
	}

	return &IncludeExternalRepoPercolator{fn: updateNodeIncludeExternalRepo(root)}, nil
}

func updateNodeIncludeExternalRepo(root tree.Expr) func(document *IncludeExternalRepo) bool {
	switch r := root.(type) {
	case *tree.And:
		fns := make([]func(document *IncludeExternalRepo) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeIncludeExternalRepo(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pIncludeExternalRepoFalseFn).Pointer() {
				return pIncludeExternalRepoFalseFn
			}
			fns = append(fns, fn)
		}

		return func(document *IncludeExternalRepo) bool {
			for _, fn := range fns {
				if !fn(document) {
					return false
				}
			}
			return true
		}
	case *tree.Or:
		fns := make([]func(document *IncludeExternalRepo) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeIncludeExternalRepo(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pIncludeExternalRepoFalseFn).Pointer() {
				continue
			}
			fns = append(fns, fn)
		}

		if len(fns) == 0 {
			return pIncludeExternalRepoFalseFn
		}

		return func(document *IncludeExternalRepo) bool {
			for _, fn := range fns {
				if fn(document) {
					return true
				}
			}
			return false
		}
	case *tree.Not:
		child := updateNodeIncludeExternalRepo(r.Child)
		return func(document *IncludeExternalRepo) bool {
			return !child(document)
		}
	case *tree.Query:
		return pIncludeExternalRepoQuery(r)
	}

	return pIncludeExternalRepoFalseFn
}

type GroupPercolator struct {
	fn func(document *jen.Group) bool
}

// Percolate percolates the document with the percolator's query.
// It will return a boolean indicating if the query matches the document.
func (p *GroupPercolator) Percolate(document *jen.Group) bool {
	return p.fn(document)
}

// NewGroupPercolatorConstructor is a constructor of percolators.
// Every percolator it creates will use the parser provided to the constructor.
func NewGroupPercolatorConstructor(parseFn tree.ParseFn, modifiers ...tree.Modifiers) func(query string) (*GroupPercolator, error) {
	return func(query string) (*GroupPercolator, error) {
		return NewGroupPercolator(parseFn, query, modifiers...)
	}
}

// NewGroupPercolator creates a percolator with a given query and a given parser.
// It returns an error if the parsing failed.
func NewGroupPercolator(parseFn tree.ParseFn, query string, modifiers ...tree.Modifiers) (*GroupPercolator, error) {
	root, err := parseFn(query)
	if err != nil {
		return nil, err
	}

	for _, modifier := range modifiers {
		root = modifier(root)
		if _, isEmpty := root.(*tree.Empty); isEmpty {
			// If the query is empty, we return a percolator that always returns false
			return &GroupPercolator{fn: pGroupFalseFn}, nil
		}
	}

	return &GroupPercolator{fn: updateNodeGroup(root)}, nil
}

func updateNodeGroup(root tree.Expr) func(document *jen.Group) bool {
	switch r := root.(type) {
	case *tree.And:
		fns := make([]func(document *jen.Group) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeGroup(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pGroupFalseFn).Pointer() {
				return pGroupFalseFn
			}
			fns = append(fns, fn)
		}

		return func(document *jen.Group) bool {
			for _, fn := range fns {
				if !fn(document) {
					return false
				}
			}
			return true
		}
	case *tree.Or:
		fns := make([]func(document *jen.Group) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeGroup(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pGroupFalseFn).Pointer() {
				continue
			}
			fns = append(fns, fn)
		}

		if len(fns) == 0 {
			return pGroupFalseFn
		}

		return func(document *jen.Group) bool {
			for _, fn := range fns {
				if fn(document) {
					return true
				}
			}
			return false
		}
	case *tree.Not:
		child := updateNodeGroup(r.Child)
		return func(document *jen.Group) bool {
			return !child(document)
		}
	case *tree.Query:
		return pGroupQuery(r)
	}

	return pGroupFalseFn
}

type TimePercolator struct {
	fn func(document *time.Time) bool
}

// Percolate percolates the document with the percolator's query.
// It will return a boolean indicating if the query matches the document.
func (p *TimePercolator) Percolate(document *time.Time) bool {
	return p.fn(document)
}

// NewTimePercolatorConstructor is a constructor of percolators.
// Every percolator it creates will use the parser provided to the constructor.
func NewTimePercolatorConstructor(parseFn tree.ParseFn, modifiers ...tree.Modifiers) func(query string) (*TimePercolator, error) {
	return func(query string) (*TimePercolator, error) {
		return NewTimePercolator(parseFn, query, modifiers...)
	}
}

// NewTimePercolator creates a percolator with a given query and a given parser.
// It returns an error if the parsing failed.
func NewTimePercolator(parseFn tree.ParseFn, query string, modifiers ...tree.Modifiers) (*TimePercolator, error) {
	root, err := parseFn(query)
	if err != nil {
		return nil, err
	}

	for _, modifier := range modifiers {
		root = modifier(root)
		if _, isEmpty := root.(*tree.Empty); isEmpty {
			// If the query is empty, we return a percolator that always returns false
			return &TimePercolator{fn: pTimeFalseFn}, nil
		}
	}

	return &TimePercolator{fn: updateNodeTime(root)}, nil
}

func updateNodeTime(root tree.Expr) func(document *time.Time) bool {
	switch r := root.(type) {
	case *tree.And:
		fns := make([]func(document *time.Time) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeTime(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pTimeFalseFn).Pointer() {
				return pTimeFalseFn
			}
			fns = append(fns, fn)
		}

		return func(document *time.Time) bool {
			for _, fn := range fns {
				if !fn(document) {
					return false
				}
			}
			return true
		}
	case *tree.Or:
		fns := make([]func(document *time.Time) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeTime(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pTimeFalseFn).Pointer() {
				continue
			}
			fns = append(fns, fn)
		}

		if len(fns) == 0 {
			return pTimeFalseFn
		}

		return func(document *time.Time) bool {
			for _, fn := range fns {
				if fn(document) {
					return true
				}
			}
			return false
		}
	case *tree.Not:
		child := updateNodeTime(r.Child)
		return func(document *time.Time) bool {
			return !child(document)
		}
	case *tree.Query:
		return pTimeQuery(r)
	}

	return pTimeFalseFn
}

func pIncludeExternalRepoQuery(query *tree.Query) func(*IncludeExternalRepo) bool {
	key, suffix, _ := strings.Cut(query.Key, ".")
	_ = suffix
	switch key {
	case "time":
		fn := pTimeQuery(&tree1.Query{
			Key:   suffix,
			Sign:  query.Sign,
			Value: query.Value,
		})
		return func(document *IncludeExternalRepo) bool {
			return fn(&document.Time)
		}
	case "group":
		fn := pGroupQuery(&tree1.Query{
			Key:   suffix,
			Sign:  query.Sign,
			Value: query.Value,
		})
		return func(document *IncludeExternalRepo) bool {
			return fn(&document.Group)
		}
	default:
		return pIncludeExternalRepoFalseFn
	}
}

func pIncludeExternalRepoFalseFn(_ *IncludeExternalRepo) bool {
	return false
}

func pGroupQuery(query *tree.Query) func(*jen.Group) bool {
	key, suffix, _ := strings.Cut(query.Key, ".")
	_ = suffix
	switch key {

	default:
		return pGroupFalseFn
	}
}

func pGroupFalseFn(_ *jen.Group) bool {
	return false
}

func pTimeQuery(query *tree1.Query) func(*time.Time) bool {
	parsed, err := time.Parse(time.RFC3339, query.Value)
	if err != nil {
		return pTimeFalseFn
	}
	switch query.Sign {
	case tree.Eq:
		return func(t *time.Time) bool {
			return t.Equal(parsed)
		}
	case tree.Lt:
		return func(t *time.Time) bool {
			return t.Before(parsed)
		}
	case tree.Lte:
		return func(t *time.Time) bool {
			return t.Before(parsed) || t.Equal(parsed)
		}
	case tree.Gt:
		return func(t *time.Time) bool {
			return parsed.Before(*t)
		}

	case tree.Gte:
		return func(t *time.Time) bool {
			return parsed.Before(*t) || parsed.Equal(*t)
		}
	}
	return pTimeFalseFn
}

func pTimeFalseFn(_ *time.Time) bool {
	return false
}
