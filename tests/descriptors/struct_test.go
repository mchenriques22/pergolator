package descriptors

import (
	"bytes"
	"go/parser"
	"go/token"
	"os"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/mchenriques22/pergolator/codegen"
)

const (
	testStructFileName = "struct_test_gen.go"
	testStruct         = `package descriptors
type MyStruct struct {
	BasicString  string
	IgnoredField bool
}
`
)
const expected = `// Code generated by github.com/antoninferrand/pergolator, DO NOT EDIT.
package codegen

import (
	"reflect"
	"strings"

	"github.com/antoninferrand/pergolator/tests/descriptors"

	"github.com/antoninferrand/pergolator/tree"
)

type MyStructPercolator struct {
	fn func(document *descriptors.MyStruct) bool
}

// Percolate percolates the document with the percolator's query.
// It will return a boolean indicating if the query matches the document.
func (p *MyStructPercolator) Percolate(document *descriptors.MyStruct) bool {
	return p.fn(document)
}

// NewMyStructPercolatorConstructor is a constructor of percolators.
// Every percolator it creates will use the parser provided to the constructor.
func NewMyStructPercolatorConstructor(parseFn tree.ParseFn, modifiers ...tree.Modifiers) func(query string) (*MyStructPercolator, error) {
	return func(query string) (*MyStructPercolator, error) {
		return NewMyStructPercolator(parseFn, query, modifiers...)
	}
}

// NewMyStructPercolator creates a percolator with a given query and a given parser.
// It returns an error if the parsing failed.
func NewMyStructPercolator(parseFn tree.ParseFn, query string, modifiers ...tree.Modifiers) (*MyStructPercolator, error) {
	root, err := parseFn(query)
	if err != nil {
		return nil, err
	}

	for _, modifier := range modifiers {
		root = modifier(root)
		if _, isEmpty := root.(*tree.Empty); isEmpty {
			// If the query is empty, we return a percolator that always returns false
			return &MyStructPercolator{fn: pMyStructFalseFn}, nil
		}
	}

	return &MyStructPercolator{fn: updateNodeMyStruct(root)}, nil
}

func updateNodeMyStruct(root tree.Expr) func(document *descriptors.MyStruct) bool {
	switch r := root.(type) {
	case *tree.And:
		fns := make([]func(document *descriptors.MyStruct) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeMyStruct(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pMyStructFalseFn).Pointer() {
				return pMyStructFalseFn
			}
			fns = append(fns, fn)
		}

		return func(document *descriptors.MyStruct) bool {
			for _, fn := range fns {
				if !fn(document) {
					return false
				}
			}
			return true
		}
	case *tree.Or:
		fns := make([]func(document *descriptors.MyStruct) bool, 0, len(r.Children))
		for _, child := range r.Children {
			fn := updateNodeMyStruct(child)

			// Optimize the case where one of the children is always false
			if reflect.ValueOf(fn).Pointer() == reflect.ValueOf(pMyStructFalseFn).Pointer() {
				continue
			}
			fns = append(fns, fn)
		}

		if len(fns) == 0 {
			return pMyStructFalseFn
		}

		return func(document *descriptors.MyStruct) bool {
			for _, fn := range fns {
				if fn(document) {
					return true
				}
			}
			return false
		}
	case *tree.Not:
		child := updateNodeMyStruct(r.Child)
		return func(document *descriptors.MyStruct) bool {
			return !child(document)
		}
	case *tree.Query:
		return pMyStructQuery(r)
	}

	return pMyStructFalseFn
}

func pMyStructQuery(query *tree.Query) func(*descriptors.MyStruct) bool {
	key, suffix, _ := strings.Cut(query.Key, ".")
	_ = suffix
	switch key {
	case "renamed":
		parsed := query.Value
		return func(document *descriptors.MyStruct) bool {
			return document.BasicString == parsed
		}
	default:
		return pMyStructFalseFn
	}
}

func pMyStructFalseFn(_ *descriptors.MyStruct) bool {
	return false
}
`

func TestDescriptor(t *testing.T) {
	// Set up the test
	file, err := os.OpenFile(testStructFileName, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0o644)
	require.NoError(t, err)
	defer func() {
		require.NoError(t, file.Close())
	}()
	defer func() {
		require.NoError(t, os.Remove(testStructFileName))
	}()
	_, err = file.WriteString(testStruct)

	// Run the test
	var buffer bytes.Buffer
	err = codegen.Run(&buffer, "codegen", "descriptor.json", []string{"github.com/antoninferrand/pergolator/tests/descriptors.MyStruct"}, 2, false)
	require.NoError(t, err)
	assert.Equal(t, expected, buffer.String())

	_, err = parser.ParseFile(token.NewFileSet(), "", buffer.String(), parser.AllErrors)
	assert.NoError(t, err)
}
